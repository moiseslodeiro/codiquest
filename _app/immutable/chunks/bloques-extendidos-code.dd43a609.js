import{s as D}from"./scheduler.38f5b73a.js";import{S as G,i as A,r as L,u as P,v as H,d as M,t as y,w as z,g as $,s as g,h as _,x,c as v,k as Y,a as i,f as r,m as R,n as S}from"./index.33e8e8ec.js";import{C as I}from"./Code.7e3a14be.js";import{b as J}from"./paths.e092a00d.js";import{P as K}from"./File.svelte_svelte_type_style_lang.e9c0277e.js";import{F as N}from"./File.6bc0c696.js";import{B as O}from"./Browser.510db479.js";function Q(p){let t;return{c(){t=R(`¡Y ahora vamos a imprimir los números del 0 al 9 haciendo uso de javascript vanilla!

\`\`\`js
for(let i = 0; i < 10; i++) {
  console.log(i);
)
\`\`\`
`)},l(n){t=S(n,`¡Y ahora vamos a imprimir los números del 0 al 9 haciendo uso de javascript vanilla!

\`\`\`js
for(let i = 0; i < 10; i++) {
  console.log(i);
)
\`\`\`
`)},m(n,s){i(n,t,s)},d(n){n&&r(t)}}}function U(p){let t;return{c(){t=R(`for(let i = 0; i < 10; i++) {
  console.log(i);
)`)},l(n){t=S(n,`for(let i = 0; i < 10; i++) {
  console.log(i);
)`)},m(n,s){i(n,t,s)},d(n){n&&r(t)}}}function V(p){let t,n="¡Y ahora vamos a imprimir los números del 0 al 9 haciendo uso de javascript vanilla!",s,a,m;return a=new I({props:{codeLang:"js",$$slots:{default:[U]},$$scope:{ctx:p}}}),{c(){t=$("p"),t.textContent=n,s=g(),L(a.$$.fragment)},l(o){t=_(o,"P",{"data-svelte-h":!0}),x(t)!=="svelte-17g8nk2"&&(t.textContent=n),s=v(o),P(a.$$.fragment,o)},m(o,c){i(o,t,c),i(o,s,c),H(a,o,c),m=!0},p(o,c){const u={};c&1&&(u.$$scope={dirty:c,ctx:o}),a.$set(u)},i(o){m||(M(a.$$.fragment,o),m=!0)},o(o){y(a.$$.fragment,o),m=!1},d(o){o&&(r(t),r(s)),z(a,o)}}}function W(p){let t,n=`En la introducción a los <a href="${J}/componentes/componentes-code" class="link link-primary internal">componentes</a>, pudimos ver el componente <code class="svelte-1awqwjz">Code</code>, que resaltaba la sintaxis del lenguaje que pusiéramos. Esto, en sí, no es algo nuevo dentro de la sintaxis, ya que es algo propio de <a href="https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-and-highlighting-code-blocks#syntax-highlighting" class="link link-primary github" target="_blank" rel="noopener noreferrer">GitHub Flavored Markdown</a>. La única diferencia es cómo se representa este bloque dentro de la plantilla <code class="svelte-1awqwjz">Page</code> en Codiquest.`,s,a,m="Dicho de otra manera, si tenemos un fichero Markdown con un contenido similar a este:",o,c,u,E="El resultado sería:",b,h,C,f,k,w,q,d,T='La sintaxis de este bloque de código es bastante sencilla: se incluye el segmento de código que quieras mostrar entre tres comillas de acento grave (también conocidas como comillas invertidas o, en inglés, <em>backticks</em>), seguido del lenguaje que se quiera mostrar (revisa el apartado <a href="omponents/componentes-code" class="link link-primary internal">Componentes - Code</a> para saber cómo agregar más lenguajes al resaltado de sintaxis).',j;return c=new N({props:{icon:"markdown",route:"src,foo",name:"test.md",codeLang:"markdown",$$slots:{default:[Q]},$$scope:{ctx:p}}}),f=new O({props:{$$slots:{default:[V]},$$scope:{ctx:p}}}),{c(){t=$("p"),t.innerHTML=n,s=g(),a=$("p"),a.textContent=m,o=g(),L(c.$$.fragment),u=$("p"),u.textContent=E,b=g(),h=$("hr"),C=g(),L(f.$$.fragment),k=g(),w=$("hr"),q=g(),d=$("p"),d.innerHTML=T,this.h()},l(e){t=_(e,"P",{"data-svelte-h":!0}),x(t)!=="svelte-1ujfh9o"&&(t.innerHTML=n),s=v(e),a=_(e,"P",{"data-svelte-h":!0}),x(a)!=="svelte-bwtori"&&(a.textContent=m),o=v(e),P(c.$$.fragment,e),u=_(e,"P",{"data-svelte-h":!0}),x(u)!=="svelte-1ku2p1a"&&(u.textContent=E),b=v(e),h=_(e,"HR",{class:!0}),C=v(e),P(f.$$.fragment,e),k=v(e),w=_(e,"HR",{class:!0}),q=v(e),d=_(e,"P",{"data-svelte-h":!0}),x(d)!=="svelte-njnd22"&&(d.innerHTML=T),this.h()},h(){Y(h,"class","svelte-1awqwjz"),Y(w,"class","svelte-1awqwjz")},m(e,l){i(e,t,l),i(e,s,l),i(e,a,l),i(e,o,l),H(c,e,l),i(e,u,l),i(e,b,l),i(e,h,l),i(e,C,l),H(f,e,l),i(e,k,l),i(e,w,l),i(e,q,l),i(e,d,l),j=!0},p(e,l){const B={};l&1&&(B.$$scope={dirty:l,ctx:e}),c.$set(B);const F={};l&1&&(F.$$scope={dirty:l,ctx:e}),f.$set(F)},i(e){j||(M(c.$$.fragment,e),M(f.$$.fragment,e),j=!0)},o(e){y(c.$$.fragment,e),y(f.$$.fragment,e),j=!1},d(e){e&&(r(t),r(s),r(a),r(o),r(u),r(b),r(h),r(C),r(k),r(w),r(q),r(d)),z(c,e),z(f,e)}}}function X(p){let t,n;return t=new K({props:{$$slots:{default:[W]},$$scope:{ctx:p}}}),{c(){L(t.$$.fragment)},l(s){P(t.$$.fragment,s)},m(s,a){H(t,s,a),n=!0},p(s,[a]){const m={};a&1&&(m.$$scope={dirty:a,ctx:s}),t.$set(m)},i(s){n||(M(t.$$.fragment,s),n=!0)},o(s){y(t.$$.fragment,s),n=!1},d(s){z(t,s)}}}class le extends G{constructor(t){super(),A(this,t,null,X,D,{})}}export{le as default};
